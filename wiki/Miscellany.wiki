#summary Plus a few other things...
#labels Deprecated

= Special Methods =

A few of the special methods have already been covered, for example `__add__` and `__iadd__` (the `+` and `+=` operators) and `__getitem__` and `__setitem__` (reading and setting slices via `[]`). Here are the rest:

== `__len__` ==
This implements the `len` function and returns the length of the `BitString` in bits. There's not much more to say really, except to emphasise that it is always in bits and never bytes.
{{{
a = BitString('0x00')
print len(a)                  # 8
}}}
== `__str__` ==
This gets called when you try to print a `BitString`. As `BitString` objects have no preferred interpretation the form printed might not be what you want - if not then use the `hex`, `bin`, `int` etc. properties. The main use here is in interactive sessions when you just want a quick look at the `BitString`.

If the `BitString` is a whole number of bytes then a hexadecimal interpretation is used, otherwise binary is used. If the resulting string is more than about 2000 characters then it will be truncated with '...'.
{{{
a = BitString('0b1111 111')
print a                       # 0b1111111
a += '0b1'
print a                       # 0xff
print a.bin                   # 0b11111111
}}}

== `__eq__` , `__ne__` ==
The equality of two `BitString` objects is determined by their binary representations being equal. If you have a different criterion you wish to use then code it explicitly, for example `a.int == b.int` could be true even if `a == b` wasn't (as they could be different lengths).

Note that two `BitString` objects can have different offsets, but still be equal if their binary representations are equal.
{{{
a = BitString('0b0010')
b = BitString('0x2')
print a == b                  # True
print a != b                  # False
}}}

== `__hex__` , `__oct__` ==
You can if you wish use the built-in functions `hex()` and `oct()` instead of the `hex` and `oct` properties, although for consistency it is probably better to stick to using the properties. Note that octals are always prefixed by '`0o`' rather than just '`0`'. Note also that although a `bin()` built-in function was introduced in Python 2.6 there doesn't seem to be a corresponding `__bin__` special function, for reasons that escape me, so you can't use `bin()` on a `BitString`.
{{{
a = BitString('0o7777')
print a.oct                   # 0o7777
print oct(a)                  # 0o7777
print a.hex                   # 0xfff
print hex(a)                  # 0xfff
}}}

== `__invert__` ==
To invert all the bits in a `BitString` use the `~` operator.
{{{
a = BitString('0b0001100111')
print a                       # 0b0001100111
print ~a                      # 0b1110011000
print ~~a == a                # True
}}}

== `__lshift__` , `__rshift__` , `__ilshift__` , `__irshift__` ==
Bitwise shifts can be achieved using `<<`, `>>`, `<<=` and `>>=`. 

== `__mul__` , `__imul__` , `__rmul__` ==

== `__copy__` ==
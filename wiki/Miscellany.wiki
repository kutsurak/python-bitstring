#summary Plus a few other things...
----
*Previous:* [DeconstructingBitStrings Deconstructing BitStrings]
----
= Other Functions =
== empty() ==
Returns `True` if the `BitString` contains no data (i.e. has zero length). Otherwise returns `False`.
{{{
a = BitString()
print a.empty()               # True
}}}

== bytealign() == 
This function advances between zero and seven bits to make the `bitpos` a multiple of eight. It returns the number of bits advanced.
{{{
a = BitString('0x11223344')
a.bitpos = 1
skipped = a.bytealign()
print skipped, a.bitpos       # 7, 8
skipped = a.bytealign()
print skipped, a.bitpos       # 0, 8
}}}
== reversebits() ==
This simply reverses all of the bits of the `BitString` in place.
{{{
a = BitString('0b000001101')
a.reversebits()
print a.bin                   # 0b101100000
}}}

= Special Methods =

A few of the special methods have already been covered, for example `__add__` and `__iadd__` (the `+` and `+=` operators) and `__getitem__` and `__setitem__` (reading and setting slices via `[]`). Here are the rest:

== `__len__` ==
This implements the `len` function and returns the length of the `BitString` in bits. There's not much more to say really, except to emphasise that it is always in bits and never bytes.
{{{
a = BitString('0x00')
print len(a)                  # 8
}}}
== `__str__` ==
This gets called when you try to print a `BitString`. As `BitString` objects have no preferred interpretation the form printed might not be what you want - if not then use the `hex`, `bin`, `int` etc. properties. The main use here is in interactive sessions when you just want a quick look at the `BitString`.

If the `BitString` is a whole number of bytes then a hexadecimal interpretation is used, otherwise binary is used. If the resulting string is more than about 2000 characters then it will be truncated with '...'.
{{{
a = BitString('0b1111 111')
print a                       # 0b1111111
a += '0b1'
print a                       # 0xff
print a.bin                   # 0b11111111
}}}

== `__eq__` , `__ne__` ==
The equality of two `BitString` objects is determined by their binary representations being equal. If you have a different criterion you wish to use then code it explicitly, for example `a.int == b.int` could be true even if `a == b` wasn't (as they could be different lengths).

Note that two `BitString` objects can have different offsets, but still be equal if their binary representations are equal.
{{{
a = BitString('0b0010')
b = BitString('0x2')
print a == b                  # True
print a != b                  # False
}}}

You can also compare with a string that will be used to create a `BitString` using its `auto` initialiser (i.e. a string starting with '`0b`', '`0x`' or '`0o`').
{{{
a = BitString('0b00011111')
print a == '0x1f'             # True
print a[0:6] == '0o01'        # True
}}}            

== `__hex__` , `__oct__` ==
You can if you wish use the built-in functions `hex()` and `oct()` instead of the `hex` and `oct` properties, although for consistency it is probably better to stick to using the properties. Note that octals are always prefixed by '`0o`' rather than just '`0`'. Note also that although a `bin()` built-in function was introduced in Python 2.6 there doesn't seem to be a corresponding `__bin__` special function, for reasons that escape me, so you can't use `bin()` on a `BitString`.
{{{
a = BitString('0o7777')
print a.oct                   # 0o7777
print oct(a)                  # 0o7777
print a.hex                   # 0xfff
print hex(a)                  # 0xfff
}}}

== `__invert__` ==
To invert all the bits in a `BitString` use the `~` operator.
{{{
a = BitString('0b0001100111')
print a                       # 0b0001100111
print ~a                      # 0b1110011000
print ~~a == a                # True
}}}

== `__lshift__` , `__rshift__` , `__ilshift__` , `__irshift__` ==
Bitwise shifts can be achieved using `<<`, `>>`, `<<=` and `>>=`. Bits shifted off the left or right are replaced with zero bits. If you need special behaviour, such as keeping the sign of two's complement integers then do the shift on the property instead.
{{{
a = BitString('0b10011001')
b = a << 2
print b                       # 0b01100100
a >>= 2
print a                       # 0b00100110
}}}

== `__mul__` , `__imul__` , `__rmul__` ==
Multiplication of a `BitString` by an integer means the same as it does for ordinary strings: concatenation of multiple copies of the `BitString`.
{{{
a = BitString('0b10')
b = a*10
print b                       # 0b10101010101010101010
a *= 2
print a                       # 0b1010
}}}

== `__copy__` ==
This allows the `BitString` to be copied via the `copy` module.
{{{
import copy
a = BitString('0x4223fbddec2231')
b = copy.copy(a)
}}}
It's not terribly exciting, and isn't even the preferred method of making a copy. Using `b = BitString(a)` is my favourite, but `b = a[:]` may be more familiar to some.

== `__and__` , `__or__` , `__xor__` ==
Bit-wise AND, OR and XOR are provided for `BitString` objects of equal length only (otherwise a `ValueError` is raised). The right-hand-side of expression can be a string to use in the `auto` initialiser.
{{{
a = BitString('0b00001111')
b = BitString('0b01010101')
print (a&b).bin               # 0b00000101
print (a|b).bin               # 0b01011111
print (a^b).bin               #Â 0b01010000
b &= '0x1f'
print b.bin                   # 0b00010101
}}}
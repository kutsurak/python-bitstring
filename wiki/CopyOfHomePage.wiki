#labels Deprecated
*bitstring* is a pure Python module that aids in the construction, analysis and modification of binary data.

==Overview==

The bitstring module provides one feature-rich class, `BitString`, containing binary data which can be interpreted as, or constructed from, hexadecimal, octal or binary strings, signed or unsigned integers, and signed or unsigned exponential-Golomb coded integers. It can also be used as and created from plain Python strings, or initialised from a file.

The module is provided with a comprehensive set of unit tests and has been tested with Python 2.4, 2.5 and 2.6. There is also a separate version available for Python 3.0.

For the best introduction, see the [Tutorial], which is split up into these pages:

  * [IntroducingBitStrings Introduction]
  * [CreatingBitStrings Creating BitStrings]
  * [InterpretingBitStrings Interpreting BitStrings]
  * [DeconstructingBitStrings Deconstructing BitStrings]
  * [ModifyingBitStrings Modifying BitStrings]
  * [Miscellany Miscellany]

----

==Example usage==

Different interpretations, slicing and concatenation:
{{{
>>> a = BitString(uint=5647, length=16)
>>> a.hex, a.bin, a.uint
('0x160f', '0b0001011000001111', 5647)
>>> a[3:9].bin, a[3:9].int
('0b101100', -20)
>>> (a[0:4] + '0xf').hex
'0x1f'
}}}

Reading data sequentially. Note that the data would more usually come from a `read()` on a binary file.
{{{
>>> b = BitString(data='\x00\x00\x01\xb3\x16\x01\x20\x4f')
>>> b.readbytes(4).hex
'0x000001b3'
>>> b.readbits(12).uint
352
>>> b.readbits(12).uint
288
>>> b.readbits(3).bin
0b010
}}}

Searching, inserting and deleting:
{{{
>>> c = BitString(bin='00010010010010001111')   # c.hex == '0x1248f'
>>> c.find('0x48')
True
>>> c.readbyte().hex
'0x48'
>>> c.insert('0b0000')
bitstring.BitString('0x12480f')
>>> c.deletebits(bits=8, bitpos=4)
bitstring.BitString('0x180f')
}}}

See the Wiki for more [Examples].

----
== News ==
----
== May xx 2009: version 0.4.2 for Python 2.x released ==

This is a minor update, and almost doesn't break compatibility with version 0.4.0, but with the slight exception of `findall()` returning a generator, detailed below.

== Changes in version 0.4.2 ==

=== Stepping in slices ===

The use of the step parameter (also known as the stride) in slices has been added. Its use is a little non-standard as it effectively gives a multiplicative factor to apply to the start and stop parameters, rather than skipping over bits.

For example this makes it much more convenient if you want to give slices in terms of bytes instead of bits. Instead of writing `s[a*8:b*8]` you can use `s[a:b:8]`.

When using a step the `BitString` is effectively truncated to a multiple of the step, so `s[::8]` is equal to `s` if `s` is an integer number of bytes, otherwise it is truncated by up to 7 bits. So the final seven complete 16-bit words could be written as `s[-7::16]`

Negative slices are also allowed, and should do what you'd expect. So for example `s[::-1]` returns a bit-reversed copy of `s` (which is similar to `s.reversebits()`, which does the same operation on `s` in-place). As another example, to get the first 10 bytes in reverse byte order you could use `s_bytereversed = s[0:10:-8]`.

=== Removed restrictions on `offset` ===

You can now specify an `offset` of greater than 7 bits when creating a `BitString`, and the use of `offset` is also now permitted when using the `filename` initialiser. This is useful when you want to create a `BitString` from the middle of a file without having to read the file into memory.
{{{
f = BitString(filename='reallybigfile', offset=8000000, length=32)
}}}

=== Integers can be assigned to slices ===

You can now assign an integer to a slice of a `BitString`. If the integer doesn't fit in the size of slice given then a `ValueError` exception is raised. So this is now allowed and works as expected:
{{{
s[8:16] = 106
}}}
and is equivalent to
{{{
s[8:16] = BitString(uint=106, length=8)
}}}

=== Less exceptions raised ===

Some changes have been made to slicing so that less exceptions are raised, bringing the interface closer to that for lists. So for example trying to delete past the end of the `BitString` will now just delete to the end, rather than raising a `ValueError`.

=== Initialisation from lists and tuples ===

A new option for the `auto` initialiser is to pass it a list or tuple. The items in the list or tuple are evaluated as booleans and the bits in the `BitString` are set to `1` for `True` items and `0` for `False` items. This can be used anywhere the `auto` initialiser can currently be used. For example:
{{{
>>> a = BitString([True, 7, False, 0, ()])     # 0b11000
>>> b = a + ['Yes', '']                        # Adds '0b10'
>>> (True, True, False) in a
True
}}}

=== Miscellany ===

`reversebits()` now has `startbit` and `endbit` parameters.

As an optimisation `findall()` will return a generator, rather than a list. If you still want the whole list then of course you can just call `list()` on the generator.

Improved efficiency of `rfind()`.

Couple of minor bugs fixed. See the issue tracker for details.

== April 23rd 2009: version 0.4.1 for Python 3 released ==

This release is simply a port of version 0.4.0 to Python 3.0 and will not work for Python 2.x. All the unit tests pass (of course) but beyond that only limited ad hoc testing has been done. Development is still continuing on the 2.x branch and the Python 3.0 release is a bit of an experiment; both to see what was involved in making the port, and to see if anyone is at all interested in it!

I am not planning on updating the Python 3.0 version every time I release a new Python 2.x version of bitstring, so the next update will probably have to wait until version 1.0.

----

== April 11th 2009: version 0.4.0 released ==
==Changes in version 0.4.0==

===New functions===

Added `rfind()`, `findall()`, `replace()`. These do pretty much what you'd expect -
see the docstrings or the wiki for more information.

===More special functions===

Some missing functions were added: `__repr__`, `__contains__`, `__rand__`,
`__ror__`, `_rxor__` and `__delitem__`.

===Miscellany===

A couple of small bugs were fixed (see the issue tracker).

----

There are some small backward incompatibilities relative to version 0.3.2:

===Combined `find()` and `findbytealigned()`===

`findbytealigned()` has been removed, and becomes part of `find()`. The default
start position has changed on both `find()` and `split()` to be the start of the
`BitString`. You may need to recode:
{{{
s1.find(bs)
s2.findbytealigned(bs)
s2.split(bs)
}}}
becomes
{{{
s1.find(bs, bytealigned=False, startbit=s1.bitpos)
s2.find(bs, startbit=s1.bitpos)  # bytealigned defaults to True
s2.split(bs, startbit=s2.bitpos)
}}}

===Reading off end of `BitString` no longer raises exception===

Previously a read or peek function that encountered the end of the `BitString`
would raise a `ValueError`. It will now instead return the remainder of the
`BitString`, which could be an empty `BitString`. This is closer to the file
object interface.

===Removed visibility of `offset`===

The `offset` property was previously read-only, and has now been removed from
public view altogether. As it is used internally for efficiency reasons you
shouldn't really have needed to use it. If you do then use the `_offset` parameter
instead (with caution).

----

== March 11th 2009: version 0.3.2 released ==

== Changes in version 0.3.2 ==
== Better performance ==
A number of functions (especially `find()` and `findbytealigned()`) have been sped up considerably. 

== Bit-wise operations ==
Added support for bit-wise AND (`&`), OR (`|`) and XOR (`^`). For example:
{{{
a = BitString('0b00111')
print a & '0b10101'              # '0b00101'
}}}

== Miscellany ==
Added `seekbit()` and `seekbyte()` functions. These complement the 'advance' and 'retreat' functions, although you can still just use `bitpos` and `bytepos` properties directly.
{{{
a.seekbit(100)                   # Equivalent to a.bitpos = 100
}}}

Allowed comparisons between `BitString` objects and strings. For example this will now work:
{{{
a = BitString('0b00001111')
assert a == '0x0f'
}}}
#summary The numerous ways of creating BitStrings
#labels Deprecated
----
*Previous:* [IntroducingBitStrings Introduction]

*Next:* [InterpretingBitStrings Interpreting BitStrings]
----

= Creating `BitString` objects =

You can create `BitString` objects from ordinary Python strings, hexadecimal strings or integers. Also many operations on `BitString` objects will return another `BitString`.

== Using the constructor ==
When initialising a `BitString` you need to specify at most one initialiser. These will be explained in full below, but briefly they are:

 * `auto` : A string prefixed with '0x', '0o' or '0b' to interpret as hexadecimal, octal or binary.
 * `data` : A Python string, for example read from a binary file.
 * `hex`, `oct`, `bin`: Hexadecimal, octal or binary string.
 * `int`, `uint`: Signed or unsigned binary integers.
 * `se`, `ue` : Signed or unsigned exponential-Golomb coded integers.
 * `filename` : Directly from a file.

For some of the initialisers you need to also specify the `length` in bits, for some it is optional and for others it is an error and this will be detailed below.

=== The auto initialiser ===
{{{
fromhex = BitString('0x01ffc9')
frombin = BitString('0b01')
fromoct = BitString('0o7550')
acopy   = BitString(fromoct)
}}}
The simplest way to create a `BitString` is often to use the `auto` parameter, which is the first parameter in the `__init__` function and so the `auto=` can be omitted. It accepts a string that starts with '`0x`', '`0b`' or '`0o`'. Strings that start with '`0x`' are interpreted as hexadecimal, '`0o`' implies octal, and strings starting with '0b' are interpreted as binary. It also accepts another `BitString`, and will create a copy of it. 

You can also use the `length` and `offset` parameters to specify the length in bits and an offset of up to seven bits at the start to be ignored.
{{{
z = BitString('0b00011110000000', offset=3, length=4)
print z         # 0b1111
}}}

Note that as always the `BitString` doesn't know how it was created. Initialising with octal or hex might be more convenient or natural for a particular example but it is exactly equivalent to initialising with the corresponding binary string.
{{{
print fromoct.oct     # 0o7550
print fromoct.hex     # 0xf68
print fromoct.bin     # 0b111101101000
print fromoct.uint    # 3994
print fromoct.int     # -152
print BitString('0o7777') == '0xfff'   # True
print BitString('0xf') == '0b1111'     # True
}}}

=== From raw data ===
{{{
a = BitString(data='\x00\x01\x02\xff', length=28, offset=1)
b = BitString(data=open("somefile", 'rb').read())
}}}
Here the `length` parameter is optional; it defaults to the length of the data in bits (and so will be a multiple of 8). You can use it to truncate some bits from the end of the `BitString`. The `offset` parameter is used to ignore up to seven bits at the start of the data.

=== From a file ===

Using a `filename` initialiser allows a file to be analysed without the need to read it all into memory. The way to create a file-based `BitString` is:
{{{
p = BitString(filename="my2GBfile")
}}}
which will open the file in binary read-only mode. The file will only be read as and when other operations require it, and the contents of the file will not be changed by any operations. Something to watch out for are operations that could cause a copy of large parts of the object to be made in memory, for example
{{{
p2 = p[8:]
p += '0x00'
}}}
will create two new memory-based `BitString` objects with about the same size as the whole of the file's data. This is probably not what is wanted as the reason for using the `filename` initialiser is likely to be because you don't want the whole file in memory.

=== From a hexadecimal string ===
{{{
c = BitString(hex='0x000001b3')
}}}
The initial '`0x`' or '`0X`' is optional, as once again is a `length` parameter, which can be used to truncate the end. Whitespace is also allowed and is ignored. Note that the leading zeros are significant, so the length of `c` will be 32.

If you include the initial '`0x`' then you can use the `auto` initialiser, which just happens to be the first parameter in `__init__`, so this will work equally well:
{{{
c = BitString('0x000001b3')
}}}

=== From a binary string ===
{{{
d = BitString(bin='0011 000', length=6)
print d.bin     # 0b001100
}}}
An initial '`0b`' or '`0B`' is optional. Once again a `length` can optionally be supplied to truncate the `BitString` and whitespace will be ignored.

As with hex, the `auto` initialiser will work for binary strings prefixed by '`0b`':
{{{
d = BitString('0b001100')
}}}

=== From an octal string ===
{{{
o = BitString(oct='34100')
print o.oct     # 0o34100
}}}
An initial '`0o`' or '`0O`' is optional, but '`0o`' is preferred as it is slightly more readable. Once again a `length` can optionally be supplied to truncate the `BitString` and whitespace will be ignored.

As with hex and bin, the `auto` initialiser will work for octal strings prefixed by '`0o`':
{{{
o = BitString('0o34100')
}}}

=== From an integer ===
{{{
e = BitString(uint=45, length=12)
f = BitString(int=-1, length=7)
}}}
For initialisation with signed and unsigned integers (`int` and `uint` repectively) the `length` parameter is mandatory, and must be large enough to contain the integer. So for example if `length` is 8 then `uint` can be in the range 0 to 255, while `int` can range from -128 to 127. Two's complement is used to represent negative numbers.

{{{
g = BitString(ue=12)
h = BitString(se=-4)
}}}
Here we initialise again with integers, but this time the binary representation will be exponential-Golomb codes (`ue` is unsigned, `se` is signed). For these initialisers the length of the `BitString` is fixed by the value it is initialised with, so the `length` parameter must not be supplied and it is an error to do so. If you don't know what exponential-Golomb codes are then you probably don't need to know, but they are quite interesting, so I'll quickly cover them here...

=== Exponential-Golomb codes ===
As this type of representation of integers isn't as well known as the standard binary representation I thought that a small detour to explain them might be welcome. This section can be safely skipped if you're not interested.

Exponential-Golomb codes represent integers using bit patterns that get longer for larger numbers. For unsigned and signed numbers (the `BitString` properties `ue` and `se` respectively) the patterns start like this:

|| *Unsigned* || *Signed* || *Bit pattern* ||
|| 0 || 0  || 1 ||
|| 1 || 1  || 010 ||
|| 2 || -1 || 011 ||
|| 3 || 2  || 00100 ||
|| 4 || -2 || 00101 ||
|| 5 || 3  || 00110 ||
|| 6 || -3 || 00111 ||
|| 7 || 4  || 0001000 ||
|| 8 || -4 || 0001001 ||
|| 9 || 5  || 0001010 ||
|| 10 || -5  || 0001011 ||
|| 11 || 6  || 0001100 ||
|| ... || ... || ... ||

They consist of a sequence of `n` '0' bits, followed by a '1' bit, followed by `n` more bits. The bits after the first '1' bit count upwards as ordinary binary numbers until they run out of space and an extra '0' bit needs to get included at the start.

The advantage of this method of representing integers over many other methods is that it can be quite efficient at representing small numbers without imposing a limit on the maximum number that can be represented.

*Exercise:* Using the table above decode this sequence of unsigned Exponential Golomb codes:
{{{
001001101101101011000100100101
}}}

The answer is that it decodes to 3, 0, 0, 2, 2, 1, 0, 0, 8, 4. To create this bitstring you could have written something like:
{{{
a = bitstring.join([BitString(ue=i) for i in [3,0,0,2,2,1,0,0,8,4]])
}}}
and to read it back:
{{{
while a.bitpos != a.length:
    print a.readue()
}}}

The notation `ue` and `se` for the exponential-Golomb code properties comes from the H.264 video standard, which uses these types of code a lot. The particular way that the signed integers are represented might be peculiar to this standard as I haven't seen it elsewhere (and an obvious alternative is minus the one given here), but the unsigned mapping seems to be universal.
----
*Next:* [InterpretingBitStrings Interpreting BitStrings]
----
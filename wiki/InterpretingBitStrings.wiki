#summary The multitude of ways to interpret those bits
#labels Deprecated
----
*Previous:* [CreatingBitStrings Creating BitStrings]

*Next:* [DeconstructingBitStrings Deconstructing BitStrings]
----

= Interpreting !BitStrings =

`BitString` objects don't know or care how they were created; they are just collections of bits. This means that you are quite free to interpret them in any way that makes sense.

Several Python properties are used to create interpretations for the `BitString`. These properties call functions such as `_gethex()` and `_getuint()` which will calculate and return the appropriate interpretation. This doesn't change the `BitString` in any way and it remains just a collection of bits. If you use the property again then the calculation will be repeated.

For the properties described below we will use these:
{{{
a = BitString(hex='0x123')
b = BitString(bin='0b111')
}}}

== bin ==

The most fundamental interpretation is perhaps as a binary number. The `bin` property returns a string of the binary representation of the `BitString` prefixed with `0b`. All `BitString` objects can use this property and it is used to test equality between `BitString` objects.
{{{
print a.bin              # 0b000100100011
print b.bin              # 0b111
}}}

== hex ==

For whole-byte `BitString` objects the most natural interpretation is often as hexadecimal, with each byte represented by two hex digits. Hex values are prefixed with `0x`.

If the `BitString` does not have a length that is a multiple of four then a `ValueError` exception will be raised. This is done in preference to truncating or padding the value, which could hide errors in user code.

The 'hex' built-in function can also be used, with exactly the same effect.
{{{
print a.hex              # 0x123
print hex(a)             # 0x123
print b.hex              # raises ValueError
}}}

== oct ==

For an octal interpretation use the 'oct' property or the 'oct' built-in function. Octal values are prefixed with `0o`, which is the Python 2.6/3.0 way of doing things (rather than just starting with `0`).

If the `BitString` does not have a length that is a multiple of three then a `ValueError` exception will be raised.
{{{
print a.oct              # 0o0443
print oct(a)             # 0o0443
print b.oct              # 0o7
print (b + '0b0').oct    # raises ValueError
}}}

== uint ==

To interpret the `BitString` as an unsigned integer (i.e. a non-negative integer) use the `uint` property.
{{{
print a.uint             # 283
print b.uint             # 7
}}}

== int ==

For a two's complement interpretation as a signed integer use the `int` property. If the first bit of the `BitString` is zero then the `int` and `uint` interpretations will be equal, otherwise the `int` will represent a negative number.
{{{
print a.int              # 283
print b.int              # -1
}}}

== data ==

A common need is to retrieve the raw bytes from a `BitString` for further processing or for writing to a file. For this use the `data` interpretation, which returns an ordinary Python string.

If the length of the `BitString` isn't a multiple of eight then it will be padded with between one and seven zero bits up to a byte boundary.
{{{
open('somefile', 'wb').write(a.data)
a2 = BitString(filename='somefile')
print a2.hex             # 0x1230 (Note the extra four bits needed to byte align)
}}}
== ue ==
The `ue` property interprets the `BitString` as a single unsigned exponential-Golomb code and returns an integer. If the `BitString` is not exactly one code then a `BitStringError` is raised instead. If you wish to read the next bits in the stream and interpret them as a code the use the `readue()` function. See the previous page in this tutorial for a short explanation of this type of integer representation.

== se ==
The `se` property does much the same as `ue` and the provisos there all apply. The obvious difference is that it interprets the `BitString` as a signed exponential-Golomb rather than unsigned - see the previous page in this tutorial for more information.

----
*Next:* [DeconstructingBitStrings Deconstructing BitStrings]
----
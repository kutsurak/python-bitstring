#summary The multitude of ways to interpret those bits
#labels Deprecated
----
*Next:* [ModifyingBitStrings Modifying BitStrings]
----

= Interpreting !BitStrings =

`BitString` objects don't know or care how they were created; they are just collections of bits. This means that you are quite free to interpret them in any way that makes sense.

Several Python properties are used to create interpretations for the `BitString`. These properties call functions such as `_gethex()` and `_getuint()` which will calculate and return the appropriate interpretation. This doesn't change the `BitString` in any way and it remains just a collection of bits. If you use the property again then the calculation will be repeated.

For the properties described below we will use these:
{{{
a = BitString(hex='0x123')
b = BitString(bin='0b111')
}}}

== bin ==

The most fundamental interpretation is perhaps as a binary number. The `bin` property returns a string of the binary representation of the `BitString` prefixed with `0b`. All `BitString` objects can use this property and it is used to test equality between `BitString` objects.
{{{
print a.bin              # 0b000100100011
print b.bin              # 0b111
}}}

== hex ==

For whole-byte `BitString` objects the most natural interpretation is often as hexadecimal, with each byte represented by two hex digits. Hex values are prefixed with `0x`.

If the `BitString` does not have a length that is a multiple of four then a `ValueError` exception will be raised. This is done in preference to truncating or padding the value, which could hide errors in user code.

The 'hex' built-in function can also be used, with exactly the same effect.
{{{
print a.hex              # 0x123
print hex(a)             # 0x123
print b.hex              # raises ValueError
}}}

== oct ==

For an octal interpretation use the 'oct' property or the 'oct' built-in function. Octal values are prefixed with `0o`, which is the Python 2.6/3.0 way of doing things (rather than just starting with `0`).

If the `BitString` does not have a length that is a multiple of three then a `ValueError` exception will be raised.
{{{
print a.oct              # 0o0443
print oct(a)             # 0o0443
print b.oct              # 0o7
print (b + '0b0').oct    # raises ValueError
}}}

== uint ==

To interpret the `BitString` as an unsigned integer (i.e. a non-negative integer) use the `uint` property.
{{{
print a.uint             # 283
print b.uint             # 7
}}}

== int ==

For a two's complement interpretation as a signed integer use the `int` property. If the first bit of the `BitString` is zero then the `int` and `uint` interpretations will be equal, otherwise the `int` will represent a negative number.
{{{
print a.int              # 283
print b.int              # -1
}}}

== data ==

A common need is to retrieve the raw bytes from a `BitString` for further processing or for writing to a file. For this use the `data` interpretation, which returns an ordinary Python string.

If the length of the `BitString` isn't a multiple of eight then it will be padded with between one and seven zero bits up to a byte boundary.
{{{
open('somefile', 'wb').write(a.data)
a2 = BitString(filename='somefile')
print a2.hex             # 0x1230 (Note the extra four bits needed to byte align)
}}}
== ue ==

== se ==

Some points to note:
  * If `data` is used as a 'getter' the `BitString` will be padded with zero bits up to the next byte boundary, if necessary.
  * To write to a file, open a file in binary write mode and write the `BitString` object's `data` property.
  * You can use the `int` and `uint` properties to change the contents of the `BitString`, but the length cannot be changed after creation so a `BitStringError` will be raised if the new value doesn't fit.
  * For the `data`, `hex`, `oct`, `bin`, `se` and `ue` properties the length of the `BitString` will change to accommodate the new value.
  * The only initialiser that isn't also a property is `filename`. To change the referenced file initialise a new `BitString` with the new file name.
  * The `se` and `ue` properties used as getters are only valid if the `BitString` decodes to exactly one Exponential Golomb code, otherwise a `BitStringError` is raised. The `readse()` and `readue()` functions can be used to interpret the bits following the current position as Exponential Golomb codes.
----
*Next:* [ModifyingBitStrings Modifying BitStrings]
----
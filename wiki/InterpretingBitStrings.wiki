#summary The multitude of ways to interpret those bits
#labels Deprecated
----
*Next:* [ModifyingBitStrings Modifying BitStrings]
----

= Interpreting !BitStrings =

`BitString` objects don't know or care how they were created; they are just collections of bits. This means that you are quite free to interpret them in any way that makes sense.

Several Python properties are used to create interpretations for the `BitString`. These properties call functions such as `_gethex()` and `_getuint()` which will calculate and return the appropriate interpretation. This doesn't change the `BitString` in any way and it remains just a collection of bits. If you use the property again then the calculation will be repeated.

== bin ==

The most fundamental interpretation is perhaps as a binary number. The `bin` property returns a string of the binary representation of the `BitString` prefixed with `0b`. All `BitString` objects can use this property and it is used to test equality between `BitString` objects.

Some points to note:
  * The `hex` property can only be used if the `BitString` object's length is a multiple of 4, otherwise a `BitStringError` is raised.
  * The `oct` property can only be used if the `BitString` object's length is a multiple of 3, otherwise a `BitStringError` is raised.
  * If `data` is used as a 'getter' the `BitString` will be padded with zero bits up to the next byte boundary, if necessary.
  * To write to a file, open a file in binary write mode and write the `BitString` object's `data` property.
  * You can use the `int` and `uint` properties to change the contents of the `BitString`, but the length cannot be changed after creation so a `BitStringError` will be raised if the new value doesn't fit.
  * For the `data`, `hex`, `oct`, `bin`, `se` and `ue` properties the length of the `BitString` will change to accommodate the new value.
  * The only initialiser that isn't also a property is `filename`. To change the referenced file initialise a new `BitString` with the new file name.
  * The `se` and `ue` properties used as getters are only valid if the `BitString` decodes to exactly one Exponential Golomb code, otherwise a `BitStringError` is raised. The `readse()` and `readue()` functions can be used to interpret the bits following the current position as Exponential Golomb codes.
----
*Next:* [ModifyingBitStrings Modifying BitStrings]
----
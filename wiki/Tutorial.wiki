#summary Brief tutorial on the use of the BitString module
= Contents =
<wiki:toc max_depth="3" />

= Getting Started =

First download the latest release (see the Downloads tab) and extract the contents of the zip. You will find:

  * `bitstring.py` : The bitstring module itself.
  * `test-bitstring.py` : Unit tests for the module.
  * `examples.py` : Some example code.

No installation is needed, you just need to make sure that your Python program can see `bitstring.py`, for example by putting in the same directory as the program that will use it.

In your program you now need to add
{{{
import bitstring
}}}
and optionally to avoid some repetitive typing
{{{
from bitstring import BitString
}}}

= Fundamentals =

A `BitString` object consists of some binary data and a length in bits. It also has the concept of a bit position, which is the current place from which to read substrings. 

= Creating `BitString` objects =

You can create `BitString` objects from ordinary Python strings, hexadecimal strings or integers. Also many operations on `BitString` objects will return another `BitString`.

When initialising a `BitString` you need to specify one or none of `data, hex, bin, int, uint, se, ue`. If you don't specify any of them an empty `BitString` will be created. For some of the initialisers you may need to also specify the `length` in bits.

== From a string or file ==
{{{
a = BitString(data='\x00\x01\x02\xff')
b = BitString(data=open("somefile", 'rb').read())
}}}
Here the `length` parameter is optional; it defaults to the length of the data in bits (and so will be a multiple of 8). You can use it to truncate some bits from the end of the `BitString`.

A future planned enhancement is to allow a `filename` initialiser that will allow a file to be analysed without the need to read it all into memory. The functionality is partially present at the moment but its use is not yet recommended as there are a number of unresolved issues.

== From a hexidecimal string ==
{{{
c = BitString(hex='0x000001b3')
}}}
The initial '`0x`' or '`0X`' is optional, as once again is a `length` parameter. Whitespace is also allowed and is ignored. Note that the leading zeros are significant, so the length of `c` will be 32.

== From a binary string ==
{{{
d = BitString(bin='0011 000')
}}}
Once again a `length` can optionally be supplied to truncate the `BitString` and whitespace will be ignored.

== From an integer ==
{{{
e = BitString(uint=45, length=12)
f = BitString(int=-1, length=7)
}}}
For signed and unsigned integers (`int` and `uint` repectively) the `length` parameter is mandatory, and must be large enough to contain the integer. So for example if `length` is 8 then `uint` can be in the range 0 to 255, while `int` can range from -128 to 127. Two's complement is used to represent negative numbers.
{{{
g = BitString(ue=12)
h = BitString(se=-4)
}}}
Here we initialise again with integers, but this time the binary representation will be Exponential-Golomb codes (`ue` is unsigned, `se` is signed). For these initialisers the length of the `BitString` is fixed by the value it is initialised with, so the `length` parameter must not be supplied and it is an error to do so. If you don't know what Exponential-Golomb codes are then you probably don't need to know, but they are quite interesting (Wikipedia is your friend). The `se` and `ue` notation comes from the H.264 video standard, which provides the ultimate definition.

= (Re)interpreting `BitString` objects =

`BitString` objects don't know or care how they were created, they are just collections of bits. This means that you are quite free to interpret them in any way that makes sense.

Python properties are used for this, and can also be used to reset the `BitString`.
{{{
print(a.hex)    # '0x000102ff'
print(a.bin)    # '0000000000000001001011111111'
a.hex = '0xff'
print(a.bin)    # '11111111'
print(a.int)    # -1 
}}}

= Combining and decomposing `BitString` objects =

For the purposes of combining and splitting it's best to consider `BitString` objects as being invariant, like ordinary strings. This means that new `BitString` objects will be created rather than current ones being modified. Some examples should clarify this.

== Joining ==

To join together a couple of `BitString` objects use the `+` or `+=` operators.
{{{
a = BitString(bin='0000')+BitString(hex='f')
a += BitString(uint=0, length=8)
}}}

If you want to join a large number of `BitStrings` then this can very quickly get very inefficient (just as it does with ordinary Python strings). This is because a brand-new object is being created with each addition. The function `join` can be used if many `BitString` objects need to be connected.

{{{
# Don't do it this way!
s = BitString()
for i in range(1000):
    s += BitString(uint=i, length=16)

# This is much more efficient:
bsl = []
for i in range(1000):
    bsl.append(BitString(uint=i, length=16))
s = bitstring.join(bsl)

# or, more concisely just use:
s = bitstring.join([BitString(uint=i, length=16) for i in range(1000)])
}}}

== Truncating and slicing ==

The truncate functions return new objects, rather than modifying the one that they operate on.
{{{
a = BitString(hex='0x001122')
b = a.truncateend(8)
c = b.truncatestart(8)
print(a.hex, b.hex, c.hex)  # ('0x001122', '0x0011', '0x11')
}}}

The same effect can be obtained using slicing. Note that as always the unit is bits, rather than bytes.
{{{
a = BitString(bin='00011110')
b = a[3:7]
print(b.bin) # '1111'
}}}

== Spliting ==

Sometimes it can be very useful to use a delimiter to split a `BitString` into sections. The `split()` function returns a generator for the sections.
{{{
a = BitString(hex='0x4700004711472222')
delimiter = BitString(hex='0x47')
for s in a.split(delimiter)):
    print("Empty" if s.empty() else s.hex) # 'Empty', '0x470000', '0x4711', '0x472222'
}}}
Note that the first item returned is always the `BitString` before the first occurence of the delimiter, even if it is empty. 
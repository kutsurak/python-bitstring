#summary Brief tutorial on the use of the BitString module

== Getting Started ==

First download the latest release (see the Downloads tab) and extract the contents of the zip. You will find:

  * `bitstring.py` : The bitstring module itself.
  * `test-bitstring.py` : Unit tests for the module.
  * `examples.py` : Some example code.

No installation is needed, you just need to make sure that your Python program can see `bitstring.py`, for example by putting in the same directory as the program that will use it.

In your program you now need to add
{{{
import bitstring
}}}
and optionally to avoid some repetitive typing
{{{
from bitstring import BitString
}}}

== Fundamentals ==

A !BitString object consists of some binary data and a length in bits.

== Creating !BitStrings ==

You can create !BitString objects from ordinary Python strings, hexadecimal strings or integers. Also many !BitString functions will return another !BitString.

When initialising a !BitString you need to specify one or none of `data, hex, bin, int, uint, se, ue`. If you don't specify any of them then an empty !BitString will be created. For some of the initialiser you may need to also specify the `length` - I'll go into more detail below.

=== From a string or file ===
{{{
a = BitString(data='\x00\x01\x02\xff')
b = BitString(data=open("somefile", 'rb').read())
}}}
Here the `length` parameter is optional; it defaults to the length of the data in bits (and so will be a multiple of 8). You can use it to truncate some bits from the end of the BitString.

A future planned enhancement is to allow a `filename` initialiser that will allow a file to be analysed without the need to read it all into memory. The functionality is partially present at the moment but its use is not yet recommended.

=== From hexidecimal ===
{{{
c = BitString(hex='0x000001b3')
}}}
The initial '`0x`' or '`0X`' is optional, as once again is a `length` parameter. Whitespace is also allowed and will be ignored. Note that the leading zeros are significant, so the length of `c` will be 32.

=== From binary ===
{{{
d = BitString(bin='0011 000')
}}}
Once again a `length` can optionally be supplied to truncate the !BitString and whitespace
will be ignored.

== From an integer ===
{{{
e = BitString(uint=45, length=12)
f = BitString(int=-1, length=7)
}}}





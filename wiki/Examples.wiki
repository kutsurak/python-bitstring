#summary Some simple usage examples
#labels Featured

{{{
>>> from bitstring import BitString
}}}
===Creating `BitString` objects===
From a hexadecimal string
{{{
>>> h = BitString(hex='000001b3')
}}}
From an octal string
{{{
>>> o = BitString(oct='755')
}}}
From a binary string
{{{
>>> b = BitString(bin='001001111')
}}}
hex, oct and bin using automatic interpretation
Must prefix with '0b', '0o' or '0x'
{{{
>>> h = BitString('0x000001b3')
>>> o = BitString('0o755')
>>> b = BitString('0b001001111')
}}}
From an ordinary string
{{{
>>> d = BitString(data='\x03\xff\x23')
}}}
From a file (only read as necessary)
{{{
>>> f = BitString(filename='ABigFile.ext')
}}}
With integers the length of the BitString in bits needs to be supplied. It must be long enough to contain the integer.
{{{
>>> ui = BitString(uint=15, length=6)
}}}
or
{{{
>>> ui = BitString('uint6=15')
}}}
From an integer represented as a signed exponential Golomb code
{{{
>>> e = BitString(se=-10)
}}}
===Interpreting `BitString` objects===
Python properties are used to give different interpretations of the binary data. 
{{{
>>> print h.hex
0x000001b3
>>> print b.oct
0o117
>>> print h.bin
0b00000000000000000000000110110011
>>> print ui.uint
15
>>> print ui.bin  # (note the leading zeros because we gave it a length of 6)
0b001111 
}}}
se and ue will raise a BitStringError if the BitString isn't a single code.
{{{
>>> print e.se
-10
>>> print e.bin
0b000010101
}}}

===Manipulating `BitString` objects===
Slicing
{{{
>>> print h[24:32]      # by default indices are in bits
0xb3
>>> print h[3:4:8]      # (the third byte)
0xb3   
>>> print h[-4:]        # (the final four bits)
0b0011 
}}}
Joining lists
{{{
>>> bsl = ['0b0', '0b1', BitString('uint3=5'), '0xf']
>>> print BitString().join(bsl)
0b011011111
}}}
Appending, prepending, truncating and deleting
{{{
>>> s = BitString('0x00')
>>> s.prepend('0xaa').append('0xbb')
BitString('0xaa00bb')
>>> s.truncatestart(4).truncateend(4)
BitString('0xa00b')
>>> s.deletebits(8, 4)  # delete 8 bits at bit position 4
BitString('0xab')
}}}
Using a bitstring as a source for other bitstrings
{{{
>>> s = BitString('0x00112233445566778899aabbccddeeff')
>>> print s.readbit()           
0b0
>>> s.advancebits(7)            # Move on 7 bits to byte align.
>>> print s.readbytes(3)       
0x112233
>>> s.findbytealigned('0x99aa')
True
>>> print s.readbytes(5)        
0x99aabbccdd
}}}

===Parsing structures===
{{{
# A simple example from the H.264 video standard
def seq_parameter_set_data(s):
    e = {}
    e['profile_idc'] = s.readbyte().uint
    e['constraint_set0_flag'] = s.readbit().uint
    e['constraint_set1_flag'] = s.readbit().uint
    e['constraint_set2_flag'] = s.readbit().uint
    e['constraint_set3_flag'] = s.readbit().uint
    e['reserved_zero_4bits'] = s.readbits(4).bin
    e['level_idc'] = s.readbyte().uint
    e['seq_parameter_set_id'] = s.readue()
    if e['profile_idc'] in [100, 110, 122, 244, 44, 83, 86]:
        e['chroma_format_idc'] = s.readue()
        if e['chroma_format_idc'] == 3:
            e['separate_colour_plane_flag'] == s.readbit().uint
        e['bit_depth_luma_minus8'] = s.readue()
        e['bit_depth_chroma_minus8'] = s.readue()
        # etc.
    return e

s = BitString('0x6410281bc0')
e = seq_parameter_set_data(s)
print e['profile_idc']         # 100
print e['level_idc']           # 40
print e['reserved_zero_4bits'] # 0b0000
}}}
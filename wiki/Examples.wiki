#summary Some simple usage examples
#labels Featured

{{{
from bitstring import *
}}}
===Creating BitStrings===
{{{
# From hexadecimal string, the leading '0x' is optional
h = BitString(hex='0x000001b3')

# From a binary string.
b = BitString(bin='0010011')

# With integers the length of the bitstring in bits needs to be supplied.
# It must be long enough to contain the integer.
ui = BitString(uint=15, length=6)

# From an integer represented as a signed exponential goulomb code
e = BitString(se=-10)

}}}
===Interpreting BitStrings===
{{{
print(h.hex)   # 0x000001b3
print(h.bin)   # 00000000000000000000000110110011
print(ui.uint) # 15
print(ui.bin)  # 001111 (note the leading zeros because we gave it a length of 6)
print(e.se)    # -10
print(e.bin)   # 000010101
}}}

===Manipulating BitStrings===
{{{
# Slicing
print(h[24:32].hex) # 0xb3
print(h[-4:].bin)   # 0011 (the final four bits)

# Joining lists
bsl = [BitString(bin=b) for b in ['0', '1', '000', '111']]
print(join(bsl).bin)  # 01000111

# Using a bitstring as a source for other bitstrings
s = BitString(hex='0x00112233445566778899aabbccddeeff')
print(s.readbit().bin) # 0
s.advancebits(7)       # Move on 7 bits to byte align.
print(s.readbytes(3).hex) # 0x112233

}}}
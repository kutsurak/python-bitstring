#summary Some simple usage examples
#labels Featured

{{{
from bitstring import BitString
}}}
===Creating `BitString` objects===
{{{
# From a hexadecimal string
h = BitString(hex='000001b3')

# From an octal string
o = BitString(oct='755')

# From a binary string
b = BitString(bin='001001111')

# hex, oct and bin using automatic interpretation
# Must prefix with '0b', '0o' or '0x'
h = BitString('0x000001b3')
o = BitString('0o755')
b = BitString('0b001001111')

# With integers the length of the BitString in bits needs to be supplied.
# It must be long enough to contain the integer.
ui = BitString(uint=15, length=6)

# From an integer represented as a signed exponential Golomb code
e = BitString(se=-10)

}}}
===Interpreting `BitString` objects===
{{{
# hex will raise a ValueError if the length isn't a multiple of 4
print h.hex    # 0x000001b3
# oct will raise a ValueError if the length isn't a multiple of 3
print b.oct    # 0o117
# bin can be used on all BitStrings
print h.bin    # 0b00000000000000000000000110110011
# as can int and uint
print ui.uint  # 15
print ui.bin   # 0b001111 (note the leading zeros because we gave it a length of 6)
# se and ue will raise a BitStringError if the BitString isn't a single code 
print e.se     # -10
print e.bin    # 0b000010101
}}}

===Manipulating `BitString` objects===
{{{
# Slicing
print h[24:32]      # 0xb3
print h[-4:]        # 0b0011 (the final four bits)

# Joining lists
bsl = ['0b0', '0b1', BitString(uint=5, length=3), BitString(hex='f')]
print bitstring.join(bsl)     # 0b011011111

# Appending, prepending, truncating and deleting
s = BitString('0x00')
s.prepend('0xaa').append('0xbb')
print s             # 0xaa00bb
s.truncatestart(4).truncateend(4)
print s             # 0xa00b
s.deletebits(8, 4)  # delete 8 bits at bit position 4
print s             # 0xab

# Using a bitstring as a source for other bitstrings
s = BitString('0x00112233445566778899aabbccddeeff')
print s.readbit()           # 0b0
s.advancebits(7)            # Move on 7 bits to byte align.
print s.readbytes(3)        # 0x112233
s.findbytealigned('0x99aa')
print s.readbytes(5)        # 0x99aabbccdd
}}}

===Parsing structures===
{{{
# A simple example from the H.264 video standard
def seq_parameter_set_data(s):
    e = {}
    e['profile_idc'] = s.readbyte().uint
    e['constraint_set0_flag'] = s.readbit().uint
    e['constraint_set1_flag'] = s.readbit().uint
    e['constraint_set2_flag'] = s.readbit().uint
    e['constraint_set3_flag'] = s.readbit().uint
    e['reserved_zero_4bits'] = s.readbits(4).bin
    e['level_idc'] = s.readbyte().uint
    e['seq_parameter_set_id'] = s.readue()
    if e['profile_idc'] in [100, 110, 122, 244, 44, 83, 86]:
        e['chroma_format_idc'] = s.readue()
        if e['chroma_format_idc'] == 3:
            e['separate_colour_plane_flag'] == s.readbit().uint
        e['bit_depth_luma_minus8'] = s.readue()
        e['bit_depth_chroma_minus8'] = s.readue()
        # etc.
    return e

s = BitString('0x6410281bc0')
e = seq_parameter_set_data(s)
print e['profile_idc']         # 100
print e['level_idc']           # 40
print e['reserved_zero_4bits'] # 0b0000
}}}
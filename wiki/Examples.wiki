#summary Some simple usage examples
#labels Featured

{{{
from bitstring import *
}}}
===Creating !BitStrings===
{{{
# From hexadecimal string, the leading '0x' is optional
h = BitString(hex='0x000001b3')

# From a binary string.
b = BitString(bin='0010011')

# With integers the length of the bitstring in bits needs to be supplied.
# It must be long enough to contain the integer.
ui = BitString(uint=15, length=6)

# From an integer represented as a signed exponential Golomb code
e = BitString(se=-10)

}}}
===Interpreting !BitStrings===
{{{
print(h.hex)   # 0x000001b3
print(h.bin)   # 00000000000000000000000110110011
print(ui.uint) # 15
print(ui.bin)  # 001111 (note the leading zeros because we gave it a length of 6)
print(e.se)    # -10
print(e.bin)   # 000010101
}}}

===Manipulating !BitStrings===
{{{
# Slicing
print(h[24:32].hex) # 0xb3
print(h[-4:].bin)   # 0011 (the final four bits)

# Joining lists
bsl = [BitString(bin=b) for b in ['0', '1', '000', '111']]
print(join(bsl).bin)  # 01000111

# Using a bitstring as a source for other bitstrings
s = BitString(hex='0x00112233445566778899aabbccddeeff')
print(s.readbit().bin) # 0
s.advancebits(7)       # Move on 7 bits to byte align.
print(s.readbytes(3).hex) # 0x112233

}}}

===Parsing structures===
{{{
# A simple example from the H.264 video standard
def seq_parameter_set_data(s):
  profile_idc = s.readbyte().uint
  constraint_set0_flag = s.readbit().uint
  constraint_set1_flag = s.readbit().uint
  constraint_set2_flag = s.readbit().uint
  constraint_set3_flag = s.readbit().uint
  reserved_zero_4bits = s.readbits(4).uint
  level_idc = s.readbyte().uint
  seq_parameter_set_id = s.readue()
  if profile_idc in [100, 110, 122, 244, 44, 83, 86]:
    chroma_format_idc = s.readue()
    if chroma_format_idc == 3:
      separate_colour_plane_flag == s.readbit().uint
    bit_depth_luma_minus8 = s.readue()
    bit_depth_chroma_minus8 = s.readue()
    # etc.

}}}
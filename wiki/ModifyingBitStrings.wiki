#summary Slice them, dice them, cut 'em up and splice them.
----
*Previous:* [DeconstructingBitStrings Deconstructing BitStrings]

*Next:* [Miscellany]
----
= Combining, modifying and decomposing `BitString` objects =

== Joining ==

To join together a couple of `BitString` objects use the `+` or `+=` operators, or the `append` and `prepend` functions.
{{{
# Six ways of creating the same BitString:
a1 = BitString(bin='000') + BitString(hex='f')
a2 = BitString('0b000') + BitString('0xf')
a3 = BitString('0b000') + '0xf'
a4 = BitString('0b000').append('0xf')
a5 = BitString('0xf').prepend('0b000')
a6 = BitString('0b000')
a6 += '0xf'
}}}

If you want to join a large number of `BitString` objects then the function `join` can be used to improve efficiency and readability.
{{{
# Don't do it this way!
s = BitString()
for i in range(1000):
    s = s + BitString(uint=i, length=16)

# This is much more efficient:
bsl = []
for i in range(1000):
    bsl.append(BitString(uint=i, length=16))
s = bitstring.join(bsl)

# or, more concisely just use:
s = bitstring.join([BitString(uint=i, length=16) for i in range(1000)])
}}}

== Truncating ==

The truncate functions modify the `BitString` that they operate on, but also return themselves.
{{{
a = BitString('0x001122')
a.truncateend(8)              # a.hex == '0x0011'
b = a.truncatestart(8)        # a.hex == b.hex == '0x11'
}}}
If you want to keep an unaltered version then create a copy first or use a slice
{{{
a = BitString('0b00001111')
b = BitString(a)              # equivalent to b = copy.copy(a)
b.truncatestart(1)            # a is unchanged
}}}

A similar effect can be obtained using slicing (covered in [DeconstructingBitStrings Deconstructing BitStrings]) - the major difference being that a new `BitString` is returned and the `BitString` being operated on remains unchanged.

== Inserting, deleting and overwriting ==

`insert` takes one `BitString` and inserts it into another. A bit position can be specified, but if not present then the current `bitpos` is used.
{{{
a = BitString('0x00112233')
b = BitString('0xffff')
a.insert(b, 16)
print a.hex                   # 0x0011ffff2233
}}}
You can also use a string with `insert`, which will be interpreted as a binary or hexadecimal string. So the previous example could be written without using `b` as:
{{{
a.insert('0xffff', 16)
}}}

`overwrite` does much the same as `insert`, but as you might expect the `BitString` object's data is overwritten by the new data.
{{{
a = BitString('0x00112233')
a.bitpos = 4
a.overwrite('0b1111')         # Uses current bitpos as default
print a.hex                   # 0x0f112233
}}}

`deletebits` and `deletebytes` remove sections of the `BitString`. By default they remove at the current `bitpos` - this must be at a byte boundary if using `deletebytes`:
{{{
a = BitString('0b00011000')
a.deletebits(2, 3)            # remove 2 bits at bitpos 3
print a.bin                   # 0b000000

b = BitString('0x112233445566')
b.bytepos = 3
b.deletebytes(2)
print b.hex                   # 0x11223366
}}}

== Splitting ==

Sometimes it can be very useful to use a delimiter to split a `BitString` into sections. The `split()` function returns a generator for the sections.
{{{
a = BitString('0x4700004711472222')
for s in a.split('0x47')):
    print "Empty" if s.empty() else s.hex  # Empty, 0x470000, 0x4711, 0x472222
}}}
Note that the first item returned is always the `BitString` before the first occurrence of the delimiter, even if it is empty. 


----
*Next:* [Miscellany]
----
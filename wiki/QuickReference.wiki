#summary Brief description of the bitstring module

== The bitstring Module ==

One class is provided, *!BitString*, which has the following public methods and properties.

----

*`__`add`__`* / *`__`radd`__`*

 <font color="purple">_s1 + s2_</font>

 Concatenate two _!BitStrings_ and return the result. Either _s1_ or _s2_ can be a string to be used with the _auto_ initialiser.

{{{
s = BitString(uint=34, length=8) + '0xff'
s2 = '0b101' + s 
}}}

----

*advancebit*

 <font color="purple">_s.advancebit()_</font>

 Advances position by _1_ bit. Equivalent to _s.bitpos += 1_.
----

*advancebits*
 <font color="purple">_s.advancebits(bits)_</font>

 Advances position by _bits_ bits. Equivalent to _s.bitpos += bits_.
----

*advancebyte*

 <font color="purple">_s.advancebyte()_</font>

 Advances position by _8_ bits. Equivalent to _s.bitpos += 8_. Unlike the alternative, _s.bytepos += 1_, _advancebyte_ will not raise a _!BitStringError_ if the current position is not byte-aligned.
----

*advancebytes*

 <font color="purple">_s.advancebytes(bytes)_</font>

 Advances position by _8*bytes_ bits. Equivalent to _s.bitpos += 8*bytes_. Unlike the alternative, _s.bytepos += bytes_, _advancebytes_ will not raise a _!BitStringError_ if the current position is not byte-aligned.

----

*`__`and`__`* / *`__`rand`__`*

 <font color="purple">_s1 & s2_</font>

 Returns the bit-wise AND between _s1_ and _s2_, which must have the same length otherwise a _!ValueError_ is raised. Either _s1_ or _s2_ can be a string for the _auto_ initialiser.

{{{
>>> print BitString('0x33') & '0x0f'
0x03
}}}

----

*append*

 <font color="purple">_s.append(bs)_</font>

 Join a _!BitString_ to the end of the current _!BitString_. Returns self. _bs_ can be either a _!BitString_ or a string for the _auto_ initialiser.

{{{
 s.append(BitString(hex='ffab'))
 s.append('0xffab')
}}}
----

*bin*

 <font color="purple">_s.bin_</font>

 Read and write property for setting and getting the representation of the _!BitString_ as a binary string starting with '_0b_'. When used as a getter, the returned value is always calculated - the value is never cached. When used as a setter the length of the _!BitString_ will be adjusted to fit its new contents.

{{{
 if s.bin == '0b001':
     s.bin = '0b1111'

 s.bin += '1'         # Equivalent to s.append('0b1')
}}}
----

*bitpos*

 <font color="purple">_s.bitpos_</font>

 Read and write property for setting and getting the current bit position in the _!BitString_. Can be set to any value from _0_ to _length_.
{{{
 if s.bitpos < 100:
     s.bitpos += 10
}}}
----

*bytealign*

 <font color="purple">_s.bytealign()_</font>

 Aligns to the start of the next byte (so that _bitpos_ is a multiple of 8) and returns the number of bits skipped. If the current position is already byte aligned then it is unchanged.

----

*bytepos*

 <font color="purple">_s.bytepos_</font>

 Read and write property for setting and getting the current byte position in the _!BitString_. When used as a getter will raise a _!BitStringError_ if the current position in not byte aligned.

----

*`__`contains`__`*

 <font color="purple">_bs in s_</font>

 Returns _True_ if _bs_ can be found in _s_, otherwise returns False. Equivalent to using _find_ with _bytealigned=False_, except that _bitpos_ will not be changed.

{{{
>>> '0b11' in BitString('0x06')
True
>>> '0b111' in BitString('0x06')
False
}}}

----

*`__`copy`__`*

 <font color="purple">_s.copy()_</font>

----

*data*

 <font color="purple">_s.data_</font>

 Read and write property for setting and getting the underlying byte data that contains the _!BitString_. Set using an ordinary Python string - the length will be adjusted to contain the data. When used as a getter the _!BitString_ will be padded with between zero and seven '0' bits to make it byte aligned. 

----

*deletebits*

 <font color="purple">_s.deletebits(bits, bitpos=None)_</font>

 Removes _bits_ bits from the _!BitString_ at position _bitpos_ and returns _self_. If _bitpos_ is not specified then the current position is used.

----

*deletebytes*

 <font color="purple">_s.deletebytes(bytes, bytepos=None)_</font>

 Removes _bytes_ bytes from the _!BitString_ at position _bytepos_ and returns _self_. If _bytepos_ is not specified then the current position is used, provided it is byte aligned, otherwise _!BitStringError_ is raised.


----

*`__`delitem`__`*

 <font color="purple">_del s`[`a:b`]`_</font>

----


*empty*

 <font color="purple">_s.empty()_</font>

 Returns _True_ if the _!BitString_ is empty, i.e. has _length==0_. Otherwise returns _False_.

----

*`__`eq`__`*

 <font color="purple">_s1 == s2_</font>

----
  
*find*

 <font color="purple">_s.find(bs, bytealigned=True, startbit=None, endbit=None)_</font>

 Searches for _bs_ (a _!BitString_ or string to initialise via _auto_) in the current _!BitString_ and returns _True_ if found. If _bytealigned_ is True then it will look for _bs_ only at byte aligned positions (which is generally much faster than searching for it in every possible bit position). _startbit_ and _endbit_ give the search range and default to _0_ and _self.length_ respectively.

----

*findall*

 <font color="purple">_s.findall(bs, bytealigned=True, startbit=None, endbit=None)_</font>

 Searches for all occurences of _bs_ (even overlapping ones) and returns a list of their bit positions. If _bytealigned_ is _True_ then _bs_ will only be looked for at byte aligned positions. _startbit_ and _endbit_ optionally define a slice and default to _0_ and _self.length_ respectively.

----

*`__`getitem`__`*

 <font color="purple">_s`[`a:b`]`_</font>

----

*`__`hex`__`*

 <font color="purple">_hex(s)_</font>

----

*hex*

 <font color="purple">_s.hex_</font>

 Read and write property for setting and getting the hexadecimal representation of the _!BitString_. When used as a getter the value will be preceded by '_0x_', which is optional when setting the value. If the _!BitString_ is not a multiple of four bits long then getting its _hex_ value will raise a _!ValueError_.

----

*`__`iadd`__`*

 <font color="purple">_s1 += s2_</font>

----

*`__`ilshift`__`*

 <font color="purple">_s <<= n_</font>

----

*`__`imul`__`*

 <font color="purple">_s `*`= n_</font>

----

*`__`init`__`*

 <font color="purple">_s = !BitString(auto=None, length=None, offset=0, data=None, filename=None, hex=None, bin=None, oct=None, uint=None, ue=None, se=None)_</font>

----

*insert*

 <font color="purple">_s.insert(bs, bitpos=None)_</font>

 Inserts _bs_ (a _!BitString_ or string to initialise via _auto_) at _bitpos_ and returns _self_. _bitpos_ defaults to the current position.

----

*int*

 <font color="purple">_s.int_</font>

----

*`__`invert`__`*

 <font color="purple">_~s_</font>

----

*`__`irshift`__`*

 <font color="purple">_s >>= n_</font>

----

*`__`len`__`*

 <font color="purple">_len(s)_</font>

----

*length*

 <font color="purple">_s.length_</font>

 Read-only property that gives the length of the _!BitString_ in bits.

----

*`__`lshift`__`*

 <font color="purple">_s << n_</font>

----

*`__`mul`__`*

 <font color="purple">_s `*` n_</font>

----

*`__`ne`__`*

 <font color="purple">_s1 != s2_</font>

----

*`__`oct`__`*

 <font color="purple">_oct(s)_</font>

----

*oct*

 <font color="purple">_s.oct_</font>

 Read and write property for setting and getting the octal representation of the _!BitString_. When used as a getter the value will be preceded by '_0o_', which is optional when setting the value. If the _!BitString_ is not a multiple of three bits long then getting its _oct_ value will raise a _!ValueError_.

----

*`__`or`__`* / *`__`ror`__`*

 <font color="purple">_s1 | s2_</font>

 Returns the bit-wise OR between _s1_ and _s2_, which must have the same length otherwise a _!ValueError_ is raised. Either _s1_ or _s2_ can be a string for the _auto_ initialiser.

{{{
>>> print BitString('0x33') | '0x0f'
0x3f
}}}

----

*overwrite*

 <font color="purple">_s.overwrite(bs, bitpos=None)_</font>

 Replaces the contents of the current _!BitString_ with _bs_ (a _!BitString_ or string to initialise via _auto_) at _bitpos_ and returns _self_. _bitpos_ defaults to the current position.

----

*peekbit*

 <font color="purple">_s.peekbit()_</font>

 Returns the next bit in the current _!BitString_ as a new _!BitString_ but does not advance the position.

----

*peekbits*

 <font color="purple">_s.peekbits(bits)_</font>

 Returns the next _bits_ bits of the current _!BitString_ as a new _!BitString_ but does not advance the position.

----

*peekbyte*

 <font color="purple">_s.peekbyte()_</font>

 Returns the next byte of the current _!BitString_ as a new _!BitString_ but does not advance the position.

----

*peekbytes*

 <font color="purple">_s.peekbytes(bytes)_</font>

 Returns the next _bytes_ bytes of the current _!BitString_ as a new _!BitString_ but does not advance the position.

----

*prepend*

 <font color="purple">_s.prepend(bs)_</font>

 Inserts _bs_ (which can be either a _!BitString_ or a string for the _auto_ initialiser) at the beginning of the current _!BitString_. Returns self.

----

*readbit*

 <font color="purple">_s.readbit()_</font>

 Returns the next bit of the current _!BitString_ as a new _!BitString_ and advances the position.

----

*readbits*

 <font color="purple">_s.readbits(bits)_</font>

 Returns the next _bits_ bits of the current _!BitString_ as a new _!BitString_ and advances the position.

----

*readbyte*

 <font color="purple">_s.readbyte()_</font>

 Returns the next byte of the current _!BitString_ as a new _!BitString_ and advances the position.

----

*readbytes*

 <font color="purple">_s.readbytes(bytes)_</font>

 Returns the next _bytes_ bytes of the current _!BitString_ as a new _!BitString_ and advances the position.

----

*readse*

 <font color="purple">_s.readse()_</font>

----

*readue*

 <font color="purple">_s.readue()_</font>

----

*replace*

 <font color="purple">_s.replace(old, new, bytealigned=True, startbit=None, endbit=None, count=None)_</font>

----

*`__`repr`__`*

 <font color="purple">_repr(s)_</font>

----

*retreatbit*

 <font color="purple">_s.retreatbit()_</font>

 Retreats position by _1_ bit. Equivalent to _bitpos -= 1_.

----

*retreatbits*

 <font color="purple">_s.retreatbits(bits)_</font>

 Retreats position by _bits_ bits. Equivalent to _bitpos -= bits_.

----

*retreatbyte*

 <font color="purple">_s.retreatbyte()_</font>

 Retreats position by _8_ bits. Equivalent to _bitpos -= 8_. Unlike the alternative, _bytepos -= 1_, _retreatbyte_ will not raise a _!BitStringError_ if the current position is not byte-aligned.

----

*retreatbytes*

 <font color="purple">_s.retreatbytes(bytes)_</font>

 Retreats position by _bytes*8_ bits. Equivalent to _bitpos -= 8*bytes_. Unlike the alternative, _bytepos -= bytes_, _retreatbytes_ will not raise a _!BitStringError_ if the current position is not byte-aligned.

----

*reversebits*

 <font color="purple">_s.reversebits()_</font>

----

*rfind*

 <font color="purple">_s.rfind(bs, bytealigned=True, startbit=None, endbit=None)_</font>

----

*`__`rmul`__`*

 <font color="purple">_n `*` s_</font>

----

*`__`rshift`__`*

 <font color="purple">_s >> n_</font>

----

*se*

 <font color="purple">_s.se_</font>

----

*seekbit*

 <font color="purple">_s.seekbit(bitpos)_</font>

 Moves the current position to _bitpos_. Equivalent to _s.bitpos = bitpos_.

----

*seekbyte*

 <font color="purple">_s.seekbyte(bytepos)_</font>

 Moves the current position to _bytepos_. Equivalent to _s.bytepos = bytepos_.

----

*`__`setitem`__`*

 <font color="purple">_s1`[`a:b`]` = s2_</font>

----

*slice*

 <font color="purple">_s.slice(startbit, endbit)_</font>

----

*split*

 <font color="purple">_s.split(delimiter, bytealigned=True, maxsplit=None)_</font>

----

*`__`str`__`*

 <font color="purple">_print s_</font>

----

*tellbit*

 <font color="purple">_s.tellbit()_</font>

 Returns the current bit position. Equivalent to using the _bitpos_ property as a getter.

----

*tellbyte*

 <font color="purple">_s.tellbyte()_</font>

 Returns the current byte position. Equivalent to using the _bytepos_ property as a getter, and will raise a _!BitStringError_ is the _!BitString_ is not byte aligined.

----

*truncateend*

 <font color="purple">_s.truncateend(bits)_</font>

 Remove the last _bits_ bits from the end of the _!BitString_. Returns _self_.
----

*truncatestart*

 <font color="purple">_s.truncatestart(bits)_</font>

 Remove the first _bits_ bits from the start of the _!BitString_. Returns _self_.

----

*ue*

 <font color="purple">_s.ue_</font>

----

*uint*

 <font color="purple">_s.uint_</font>

----

*`__`xor`__`* / *`__`rxor`__`*

 <font color="purple">_s1 ^ s2_</font>

 Returns the bit-wise XOR between _s1_ and _s2_, which must have the same length otherwise a _!ValueError_ is raised. Either _s1_ or _s2_ can be a string for the _auto_ initialiser.

{{{
>>> print BitString('0x33') ^ '0x0f'
0x3c
}}}

----
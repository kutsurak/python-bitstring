#summary Brief description of the bitstring module
#labels Deprecated

== The bitstring Module ==

One class is provided, *!BitString*, which has the following public methods and properties.

----

*`__`add`__`* / *`__`radd`__`*

 _s1 + s2_

 Concatenate two _!BitStrings_ and return the result. Either _s1_ or _s2_ can be a string to be used with the _auto_ initialiser.

{{{
s = BitString(uint=34, length=8) + '0xff'
s2 = '0b101' + s 
}}}

----

*advancebit*
 _s.advancebit()_

 Advances position by _1_ bit. Equivalent to _s.bitpos += 1_.
----

*advancebits*
 _s.advancebits(bits)_

 Advances position by _bits_ bits. Equivalent to _s.bitpos += bits_.
----

*advancebyte*
 _s.advancebyte()_

 Advances position by _8_ bits. Equivalent to _s.bitpos += 8_. Unlike the alternative, _s.bytepos += 1_, _advancebyte_ will not raise a _!BitStringError_ if the current position is not byte-aligned.
----

*advancebytes*
 _s.advancebytes(bytes)_

 Advances position by _8*bytes_ bits. Equivalent to _s.bitpos += 8*bytes_. Unlike the alternative, _s.bytepos += bytes_, _advancebytes_ will not raise a _!BitStringError_ if the current position is not byte-aligned.

----

*`__`and`__`* / *`__`rand`__`*

 _s1 & s2_

----

*append*
 _s.append(bs)_

 Join a _!BitString_ to the end of the current _!BitString_. Returns self. _bs_ can be either a _!BitString_ or a string for the _auto_ initialiser.

{{{
 s.append(BitString(hex='ffab'))
 s.append('0xffab')
}}}
----

*bin*
 _s.bin_

 Read and write property for setting and getting the representation of the _!BitString_ as a binary string starting with '_0b_'. When used as a getter, the returned value is always calculated - the value is never cached. When used as a setter the length of the _!BitString_ will be adjusted to fit its new contents.

{{{
 if s.bin == '0b001':
     s.bin = '0b1111'

 s.bin += '1'         # Equivalent to s.append('0b1')
}}}
----

*bitpos*
 _s.bitpos_

 Read and write property for setting and getting the current bit position in the _!BitString_. Can be set to any value from _0_ to _length_.
{{{
 if s.bitpos < 100:
     s.bitpos += 10
}}}
----

*bytealign*
 _s.bytealign()_

----

*bytepos*
 _s.bytepos_

 Read and write property for setting and getting the current byte position in the _!BitString_. When used as a getter will raise a _!BitStringError_ if the current position in not byte aligned.

----

*`__`contains`__`*

 _bs in s_

----

*`__`copy`__`*

 _s.copy()_

----

*data*
 _s.data_

 Read and write property for setting and getting the underlying byte data that contains the _!BitString_. Set using an ordinary Python string - the length will be adjusted to contain the data. When used as a getter the _!BitString_ will be padded with between zero and seven '0' bits to make it byte aligned. 

----

*deletebits*
 _s.deletebits(bits, bitpos=None)_

 Removes _bits_ bits from the _!BitString_ at position _bitpos_ and returns _self_. If _bitpos_ is not specified then the current position is used.

----

*deletebytes*
 _s.deletebytes(bytes, bytepos=None)_

 Removes _bytes_ bytes from the _!BitString_ at position _bytepos_ and returns _self_. If _bytepos_ is not specified then the current position is used, provided it is byte aligned, otherwise _!BitStringError_ is raised.

----

*empty*
 _s.empty()_

 Returns _True_ if the _!BitString_ is empty, i.e. has _length==0_. Otherwise returns _False_.

----

*`__`eq`__`*

 _s1 == s2_

----
  
*find*
 _s.find(bs, bytealigned=True, startbit=None, endbit=None)_

 Searches for _bs_ (a _!BitString_ or string to initialise via _auto_) in the current _!BitString_ and returns _True_ if found. If _bytealigned_ is True then it will look for _bs_ only at byte aligned positions (which is generally much faster than searching for it in every possible bit position). _startbit_ and _endbit_ give the search range and default to _self.bitpos_ and _self.length_ respectively.

----

*findall*
 _s.findall(bs, bytealigend=True, startbit=None, endbit=None)_

----

*`__`getitem`__`*

 _s`[`a:b`]`_

----

*`__`hex`__`*

 _hex(s)_

----

*hex*
 _s.hex_

 Read and write property for setting and getting the hexadecimal representation of the _!BitString_. When used as a getter the value will be preceded by '_0x_', which is optional when setting the value. If the _!BitString_ is not a multiple of four bits long then getting its _hex_ value will raise a _!ValueError_.

----

*`__`iadd`__`*

 _s1 += s2_

----

*`__`ilshift`__`*

 _s <<= n_

----

*`__`imul`__`*

 _s `*`= n_

----

*`__`init`__`*

 _s = !BitString(auto=None, length=None, offset=0, data=None, filename=None, hex=None, bin=None, oct=None, uint=None, ue=None, se=None)

----

*insert*
 _s.insert(bs, bitpos=None)_

 Inserts _bs_ (a _!BitString_ or string to initialise via _auto_) at _bitpos_ and returns _self_. _bitpos_ defaults to the current position.

----

*int*
 _s.int_

----

*`__`invert`__`*

 _~s_

----

*`__`irshift`__`*

 _s >>= n_

----

*`__`len`__`*

 _len(s)_

----

*length*
 _s.length_

 Read-only property that gives the length of the _!BitString_ in bits.

----

*`__`lshift`__`*

 _s << n_ 

----

*`__`mul`__`*

 _s `*` n_

----

*`__`ne`__`*

 _s1 != s2_

----

*`__`oct`__`*

 _oct(s)_

----

*oct*
 _s.oct_

 Read and write property for setting and getting the octal representation of the _!BitString_. When used as a getter the value will be preceded by '_0o_', which is optional when setting the value. If the _!BitString_ is not a multiple of three bits long then getting its _oct_ value will raise a _!ValueError_.

----

*`__`or`__`* / *`__`ror`__`*

 _s1 | s2_

----

*overwrite*
 _s.overwrite(bs, bitpos=None)_

 Replaces the contents of the current _!BitString_ with _bs_ (a _!BitString_ or string to initialise via _auto_) at _bitpos_ and returns _self_. _bitpos_ defaults to the current position.

----

*peekbit*
 _s.peekbit()_

 Returns the next bit in the current _!BitString_ as a new _!BitString_ but does not advance the position.

----

*peekbits*
 _s.peekbits(bits)_

 Returns the next _bits_ bits of the current _!BitString_ as a new _!BitString_ but does not advance the position.

----

*peekbyte*
 _s.peekbyte()_

 Returns the next byte of the current _!BitString_ as a new _!BitString_ but does not advance the position.

----

*peekbytes*
 _s.peekbytes(bytes)_

 Returns the next _bytes_ bytes of the current _!BitString_ as a new _!BitString_ but does not advance the position.

----

*prepend*
 _s.prepend(bs)_

 Inserts _bs_ (which can be either a _!BitString_ or a string for the _auto_ initialiser) at the beginning of the current _!BitString_. Returns self.

----

*readbit*
 _s.readbit()_

 Returns the next bit of the current _!BitString_ as a new _!BitString_ and advances the position.

----

*readbits*
 _s.readbits()_

 Returns the next _bits_ bits of the current _!BitString_ as a new _!BitString_ and advances the position.

----

*readbyte*
 _s.readbyte()_

 Returns the next byte of the current _!BitString_ as a new _!BitString_ and advances the position.

----

*readbytes*
 _s.readbytes(bytes)_

 Returns the next _bytes_ bytes of the current _!BitString_ as a new _!BitString_ and advances the position.

----

*readse*
 _s.readse()_

----

*readue*
 _s.readue()_

----

*replace*
 _s.replace(old, new, bytealigned=True, startbit=None, endbit=None, count=None)_

----

*retreatbit*
 _s.retreatbit()_

 Retreats position by _1_ bit. Equivalent to _bitpos -= 1_.
----

*retreatbits*
 _s.retreatbits(bits)_

 Retreats position by _bits_ bits. Equivalent to _bitpos -= bits_.

----

*retreatbyte*
 _s.retreatbyte()_

 Retreats position by _8_ bits. Equivalent to _bitpos -= 8_. Unlike the alternative, _bytepos -= 1_, _retreatbyte_ will not raise a _!BitStringError_ if the current position is not byte-aligned.

----

*retreatbytes*
 _s.retreatbytes(bytes)_

 Retreats position by _bytes*8_ bits. Equivalent to _bitpos -= 8*bytes_. Unlike the alternative, _bytepos -= bytes_, _retreatbytes_ will not raise a _!BitStringError_ if the current position is not byte-aligned.

----

*reversebits*
 _s.reversebits()_

----

*rfind*
 _s.rfind(bs, bytealigned=True, startbit=None, endbit=None)_

----

*`__`rmul`__`*

 _n `*` s_

----

*`__`rshift`__`*

 _s >> n_

----

*se*
 _s.se_

----

*seekbit*
 _s.seekbit(bitpos)_

 Moves the current position to _bitpos_. Equivalent to _s.bitpos = bitpos_.

----

*seekbyte*
 _s.seekbyte(bytepos)_

 Moves the current position to _bytepos_. Equivalent to _s.bytepos = bytepos_.

----

*`__`setitem`__`*

 _s1`[`a:b`]` = s2_

----

*slice*
 _s.slice(startbit, endbit)_

----

*split*
 _s.split(delimiter, bytealigned=True, maxsplit=None)_

----

*`__`str`__`*

 _print s_

----

*tellbit*
 _s.tellbit()_

 Returns the current bit position. Equivalent to using the _bitpos_ property as a getter.

----

*tellbyte*
 _s.tellbyte()_

 Returns the current byte position. Equivalent to using the _bytepos_ property as a getter, and will raise a _!BitStringError_ is the _!BitString_ is not byte aligined.

----

*truncateend*
 _s.truncateend(bits)_

 Remove the last _bits_ bits from the end of the _!BitString_. Returns _self_.
----

*truncatestart*
 _s.truncatestart(bits)_

 Remove the first _bits_ bits from the start of the _!BitString_. Returns _self_.

----

*ue*
 _s.ue_

----

*uint*
 _s.uint_

----

*`__`xor`__`* / *`__`rxor`__`*

 _s1 ^ s2_

----
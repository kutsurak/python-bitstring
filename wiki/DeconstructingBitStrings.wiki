#summary Reading, finding, navigating, slicing
----
*Previous:* [InterpretingBitStrings Interpreting BitStrings]

*Next:* [ModifyingBitStrings Modifying BitStrings]
----
= Navigating =

== Reading ==

A common need is to parse a large `BitString` into smaller syntax elements. Functions for reading in bytes and bits are provided and will return new `BitString` objects. These new objects are top-level `BitString` objects and can be interpreted using properties as in the next example or could be read from to form a hierarchy of reads.

Every `BitString` has a property `bitpos` which is the current position from which reads occur. `bitpos` can range from zero (its value on construction) to the length of the `BitString`, a position from which all reads will fail as it is past the last bit.

{{{
s = BitString(filename='test/test.m1v')
start_code = s.readbytes(4).hex
width = s.readbits(12).uint
height = s.readbits(12).uint
s.advancebits(37)

flags = s.readbits(2)
constrained_parameters_flag = flags.readbit().uint
load_intra_quantiser_matrix = flags.readbit().uint
}}}
In addition to the `read` functions there are matching `peek` functions. These are identical to the `read` except that they do not advance the position in the `BitString`.
{{{
s = BitString('0x4732aa34')
if s.peekbyte().hex == '0x47':
    t = s.readbytes(2)          # t.hex == '0x4732'
else:
    s.findbytealigned('0x47')
}}}

The full list of functions is `readbit()`, `readbits(n)`, `readbyte()`, `readbytes(n)`, `peekbit()`, `peekbits(n)`, `peekbyte()` and `peekbytes(n)`.

== Seeking ==
The properties `bitpos` and `bytepos` are available for getting and setting the position, which is zero on creation of the `BitString`. There are also advance, retreat and seek functions that perform equivalent actions:

|| *Using functions* ||     || *Using properties* ||
|| `advancebit()`    || <=> || `bitpos += 1`  ||
|| `advancebits(n)`  || <=> || `bitpos += n`  ||
|| `advancebyte()`   || <=> || `bytepos += 1` ||
|| `advancebytes(n)` || <=> || `bytepos += n` ||
|| `retreatbit()`    || <=> || `bitpos -= 1`  ||
|| `retreatbits(n)`  || <=> || `bitpos -= n`  ||
|| `retreatbyte()`   || <=> || `bytepos -= 1` ||
|| `retreatbytes(n)` || <=> || `bytepos -= n` ||
|| `seekbit(p)`      || <=> || `bitpos = p`   ||
|| `seekbyte(p)`     || <=> || `bytepos = p`  ||

For example:
{{{
s = BitString('0x123456')
print s.bitpos                 # 0
s.bytepos += 2
print s.bitpos                 # 16 (note bitpos verses bytepos)
s.advancebits(4)
print s.read(4).bin            # 0b0110 (the final nibble '0x6')
}}}

== Finding ==

To search for a sub-string use the 'find' and 'findbytealigned' functions. These will set the position to the start of the next occurrence of the searched for string and return `True`, or just return `False` if the string isn't present. As its name implies, `findbytealigned` looks for only byte aligned occurrences of a whole-byte `BitString`.

{{{
s = BitString('0x00123400001234')
found = s.findbytealigned('0x1234')
print(found, s.bytepos)               # True, 1
found = s.findbytealigned('0xff')
print(found, s.bytepos)               # False, 1
}}}

== Slicing ==

Slicing can be done in couple of ways. The `slice` function takes two arguments: the first bit position you want and one past the last bit position you want, so for example `a.slice(10,12)` will return a 2-bit `BitString` of the 10th and 11th bits in `a`.

An equivalent method is to use indexing: `a[10:12]`. Note that as always the unit is bits, rather than bytes.
{{{
a = BitString('0b00011110')
b = a[3:7]
c = a.slice(3, 7)             # s.slice(x, y) is equivalent to s[x:y]
print a, b, c                 # 0x1e 0b1111 0b1111
}}}

Indexing also works for missing and negative arguments, just as it does for other containers. Note though that it is not possible to specify a 'step' parameter.
{{{
a = BitString('0b00011110')
b = a[:5]        # 0b00011   (first 5 bits)            
c = a[3:]        # 0b11110   (everything except first 3 bits)
d = a[-4:]       # 0b1110    (last 4 bits)
e = a[:-1]       # 0b0001111 (everything except last 1 bit)
f = a[-6:-4]     # 0b01      (from 6 from the end to 4 from the end)
}}}

----
*Next:* [ModifyingBitStrings Modifying BitStrings]
----